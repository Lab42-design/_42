<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>_app</title>

    <link rel="icon" href="./rsrc/icons/favicon.ico" sizes="any" /><!-- 32×32 -->
    <link rel="icon" href="./rsrc/icons/icon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="./rsrc/icons/apple-touch-icon.png" /><!-- 180×180 -->
    <link rel="manifest" href="./app.webmanifest" />

    <!-- _42 stylesheets -->
    <link rel="stylesheet" href="../ui/css/reset.css" />
    <link rel="stylesheet" href="../ui/css/typography.css" />

    <!-- app stylesheets -->
    <link rel="stylesheet" href="./rsrc/app.css" />
    
</head>
<body id="partials">


<div>
<link rel="html" href="./partials/header.html" />
</div>

<div>
<link rel="html" href="./partials/content.html" />
</div>

<div>
<link rel="html" href="./partials/footer.html" />
</div>


<!-- _42 js -->
<script module src="../ui/js/promise_dom.js"></script>
<script module src="../ui/js/fetch_partial.js"></script>

<!-- app startup js -->
<script module src="./rsrc/app.js"></script>



<script>


/* global MutationObserver WebKitMutationObserver */

const awaitSelector = (selector, rootNode, fallbackDelay) => new Promise((resolve, reject) => {
  try {
    const root = rootNode
      ? typeof rootNode === 'string' ? document.querySelector(rootNode) : rootNode
      : document
    const ObserverClass = MutationObserver || WebKitMutationObserver || null
    const mutationObserverSupported = typeof ObserverClass === 'function'

    let observer

    const stopWatching = () => {
      if (observer) {
        if (mutationObserverSupported) {
          observer.disconnect()
        } else {
          clearInterval(observer)
        }

        observer = null
      }
    }

    const findAndResolveElements = () => {
      const allElements = root.querySelectorAll(selector)

      if (allElements.length === 0) return

      const newElements = []

      const attributeForBypassing = 'data-awaitselector-resolved'

      allElements.forEach((el, i) => {
        if (typeof el[attributeForBypassing] === 'undefined') {
          allElements[i][attributeForBypassing] = ''
          newElements.push(allElements[i])
        }
      })

      if (newElements.length > 0) {
        stopWatching()
        resolve(newElements)
      }
    }

    if (mutationObserverSupported) {
      observer = new ObserverClass(mutationRecords => {
        const nodesWereAdded = mutationRecords.reduce(
          (found, record) => found || (record.addedNodes && record.addedNodes.length > 0),
          false
        )

        if (nodesWereAdded) {
          findAndResolveElements()
        }
      })

      observer.observe(root, {
        childList: true,
        subtree: true,
      })
    } else {
      observer = setInterval(findAndResolveElements, fallbackDelay || 250)
    }

    findAndResolveElements()
  } catch (exception) {
    reject(exception)
  }
})

 const watchAwaitSelector = (callback, selector, rootNode, fallbackDelay) => {
  (function awaiter(continueWatching = true) {
    if (continueWatching === false) return

    awaitSelector(selector, rootNode, fallbackDelay)
      .then(callback)
      .then(awaiter)
  }())
}

// export default awaitSelector











// // a given element will only ever be detected a maximum of once
// awaitSelector('rel', '#news-feed')
//   .then(elements => { // elements is an array of native DOM elements
//     // ... do something with the new element(s) ...
//   })

// Async/Await

(async () => {
  const elements = await awaitSelector('link')
  console.log("____REL")
  // console.log(elements)
})()





</script>



<link rel="import" href="./import-0.html" />
<link rel="import" href="./import-1.html" />
<link rel="import" href="./import-2.html" />
<link rel="import" href="./import-3.html" />



</body>
</html>
